generator client {
  provider = "prisma-client"
  output   = "../src/generated"
}

datasource db {
  provider = "postgresql"
}

enum AccountType {
  USER_STASH
  PENDING_DEPOSIT
  PENDING_WITHDRAW
  EXTERNAL_CLEARING
  TREASURY_USDC
  FEES_REVENUE
}

enum EntryType {
  DEPOSIT_INITIATED
  DEPOSIT_SETTLED
  WITHDRAW_REQUESTED
  WITHDRAW_PAID
  YIELD_ACCRUED
  TREASURY_FUNDED
  FEE_CHARGED
  REVERSAL
}

enum UserTier {
  NORMIE
  CURIOUS
  POWER
  DEV
}

enum PaymentType {
  DEPOSIT
  WITHDRAW
}

enum PaymentStatus {
  CREATED
  PROCESSING
  SETTLED
  FAILED
  CANCELED
}

enum ChallengeStatus {
  ACTIVE
  PAUSED
  COMPLETED
  CANCELED
}

enum OnchainActionType {
  VAULT_DEPOSIT
  VAULT_WITHDRAW_REQUEST
  VAULT_REDEEM
}

enum OnchainStatus {
  CREATED
  SUBMITTED
  CONFIRMED
  FAILED
}

model User {
  id        String   @id @default(uuid())
  email     String?  @unique
  createdAt DateTime @default(now())

  accounts         Account[]
  paymentIntents   PaymentIntent[]
  challenges       UserChallenge[]
  yieldAllocations YieldAllocation[]
  flagOverrides    UserFlagOverride[]
  tier             UserTier @default(NORMIE)
  flags            Json?
  wallet           UserWallet?
  vaultPosition    VaultPosition?
  onchainActions   OnchainAction[]
  sessions         Session[]
  pushSubscriptions PushSubscription[]
  fundingSessions   FundingSession[]

  // Streaks (daily completion = at least one challenge save that UTC day)
  currentStreakDays  Int     @default(0)
  bestStreakDays     Int     @default(0)
  lastStreakDateUtc  String? // YYYY-MM-DD
  // POWER: streak shield (1 active at a time; when used, needs 2 saves in next window to preserve streak)
  streakShieldAvailable Boolean @default(false)
  streakShieldUsedAtUtc String?  // YYYY-MM-DD when shield entered "pending recovery"
}

model AuthToken {
  id         String    @id @default(uuid())
  email      String
  tokenHash  String    @unique
  purpose    String    // "magic_link"
  returnTo   String?   // path to redirect after login (e.g. /challenges)
  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  consumedAt DateTime?
  ip         String?
  userAgent  String?

  @@index([email])
  @@index([expiresAt])
}

model Session {
  id          String    @id @default(uuid())
  userId      String
  sessionHash String    @unique
  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  revokedAt   DateTime?
  ip          String?
  userAgent   String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model PushSubscription {
  id         String    @id @default(uuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint   String
  p256dh     String
  auth       String
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime  @default(now())
  revokedAt  DateTime?
  userAgent  String?

  @@unique([userId, endpoint])
  @@index([userId])
  @@index([revokedAt])
}

model Account {
  id        String      @id @default(uuid())
  createdAt DateTime    @default(now())

  type      AccountType
  currency  String      @default("USD")

  // nullable for "system" accounts
  userId    String?
  user      User?       @relation(fields: [userId], references: [id])

  lines     JournalLine[]

  @@index([userId, type])
}

model JournalEntry {
  id             String     @id @default(uuid())
  createdAt      DateTime   @default(now())
  occurredAt     DateTime   @default(now())

  idempotencyKey String     @unique
  type           EntryType

  // flexible metadata: provider refs, challenge ids, notes
  metadata      Json?

  lines          JournalLine[]
}

model JournalLine {
  id        String       @id @default(uuid())
  createdAt DateTime     @default(now())

  entryId   String
  entry     JournalEntry @relation(fields: [entryId], references: [id])

  accountId String
  account   Account      @relation(fields: [accountId], references: [id])

  // signed cents: + increases balance (for our convention below)
  amountCents Int

  memo      String?

  @@index([entryId])
  @@index([accountId])
}

model PaymentIntent {
  id            String        @id @default(uuid())
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  userId        String
  user          User          @relation(fields: [userId], references: [id])

  type          PaymentType
  status        PaymentStatus @default(CREATED)

  amountCents   Int
  currency      String        @default("USD")

  provider      String?       // e.g. "stripe", "ach_provider"
  providerRef   String?       // provider payment id
  idempotencyKey String       @unique

  // Links to ledger entries when created
  initiatedEntryId String?
  settledEntryId   String?
  reversedEntryId  String?

  metadata      Json?

  onchainActions OnchainAction[]
}

model ChallengeTemplate {
  id           String          @id @default(uuid())
  createdAt    DateTime        @default(now())
  slug         String          @unique
  name         String
  defaultRules Json
  challenges   UserChallenge[]
}

model UserChallenge {
  id         String            @id @default(uuid())
  createdAt  DateTime          @default(now())
  userId     String
  user       User              @relation(fields: [userId], references: [id])
  templateId String?
  template   ChallengeTemplate? @relation(fields: [templateId], references: [id])
  name       String
  status     ChallengeStatus   @default(ACTIVE)
  // for schedule-based challenges
  startDate  DateTime
  rules      Json
  settings   Json?
  // scheduler materialization
  nextRunAt  DateTime?
  lastRunAt  DateTime?
  state      Json?
  events     ChallengeEvent[]
  reminders  ChallengeReminder[]
}

model ChallengeEvent {
  id              String        @id @default(uuid())
  createdAt       DateTime      @default(now())
  userChallengeId String
  userChallenge   UserChallenge @relation(fields: [userChallengeId], references: [id])
  scheduledFor    DateTime
  idempotencyKey  String        @unique
  // deposit details decided by rules
  amountCents     Int?
  result          String? // "DEPOSIT_CREATED" | "NOOP" | "FAILED"
  paymentIntentId String?
  metadata        Json?
}

// One row per (userChallenge, due window, channel): at most one reminder per due window per channel (push vs email recap)
model ChallengeReminder {
  id              String   @id @default(uuid())
  userChallengeId String
  userChallenge   UserChallenge @relation(fields: [userChallengeId], references: [id], onDelete: Cascade)
  dueWindowKey    String   // e.g. "2026-02-05", "2026-02-02" (week anchor)
  channel         String   @default("PUSH") // PUSH | EMAIL
  sentAt          DateTime @default(now())

  @@unique([userChallengeId, dueWindowKey, channel])
  @@index([userChallengeId])
}

model YieldRun {
  id              String   @id @default(uuid())
  createdAt       DateTime @default(now())
  runKey          String   @unique
  periodStart     DateTime
  periodEnd       DateTime
  totalYieldCents Int
  status          String   @default("CREATED") // CREATED | POSTED | FAILED
  metadata        Json?
  allocations     YieldAllocation[]
}

model YieldAllocation {
  id                 String   @id @default(uuid())
  createdAt          DateTime @default(now())
  yieldRunId         String
  yieldRun           YieldRun @relation(fields: [yieldRunId], references: [id])
  userId             String
  user               User     @relation(fields: [userId], references: [id])
  userStashAccountId String
  amountCents        Int
  idempotencyKey     String   @unique
}

model FeatureFlag {
  key            String @id
  description    String
  defaultEnabled Boolean @default(false)
  tierPolicies   TierPolicy[]
  overrides      UserFlagOverride[]
}

model TierPolicy {
  id      String   @id @default(uuid())
  tier    UserTier
  flagKey String
  enabled Boolean  @default(false)

  flag    FeatureFlag @relation(fields: [flagKey], references: [key])

  @@unique([tier, flagKey])
}

model UserFlagOverride {
  id      String   @id @default(uuid())
  userId  String
  flagKey String
  enabled Boolean

  user    User        @relation(fields: [userId], references: [id])
  flag    FeatureFlag @relation(fields: [flagKey], references: [key])

  @@unique([userId, flagKey])
}

model UserWallet {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])

  address   String
  /// SMART (embedded) | EXTERNAL (e.g. Mini App connected)
  walletType String  @default("SMART")
  /// base | baseSepolia
  chain     String   @default("base")
  /// Provider-specific ref (e.g. smart wallet id) for production swap
  providerRef String?
  /// USDC micros we have already turned into deposit intents (for funding/refresh delta)
  accountedPrincipalUsdcMicros String @default("0")
  /// When we last ran funding/refresh (for UI "last checked")
  lastFundingRefreshAt DateTime?
  /// Chain balance we last observed at lastFundingRefreshAt (for UI + idempotency)
  lastObservedBalanceMicros String?
}

model FundingSession {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider  String   @default("coinbase")
  context   String?  // "pwa" | "miniapp"
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([createdAt])
}

model OnchainAction {
  id             String           @id @default(uuid())
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  userId         String
  user           User             @relation(fields: [userId], references: [id])

  type           OnchainActionType
  status         OnchainStatus    @default(CREATED)

  chain          String
  txHash         String?
  blockNumber    Int?

  paymentIntentId String?
  paymentIntent   PaymentIntent?  @relation(fields: [paymentIntentId], references: [id])

  requestId      String?

  idempotencyKey String           @unique
  metadata       Json?
}

model VaultPosition {
  id             String   @id @default(uuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  userId         String   @unique
  user           User     @relation(fields: [userId], references: [id])

  vaultAddress   String
  shares         String   // bigint as string
  totalUsdcMicros String  // bigint as string

  // cached mark-to-market value (optional)
  currentValueUsdcMicros String?
  lastMarkedAt           DateTime?
}
